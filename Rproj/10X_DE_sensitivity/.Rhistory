x <- 1:10
y <- 1:20
plot(x,y)
y <- 1:10
plot(x,y)
library(Rcpp)
install.packages("Rcpp")
library(Rcpp)
install.packages("RcppArmadillo")
library(RcppArmadillo)
library(minerva)
install.packages("minerva")
install.packages("installr")
require(installr)
install.packages("installr")
sudo add-apt-repository ppa:marutter/rrutter
version
workdir              = "/home/sam/Documents/RareCellDetection/Proj/10X_DE_sensitivity/"
# where you put the data and results
setwd(workdir)
library(pbapply)
library(future.apply)
library(ROCR)
library(Rcpp)
library(splatter)
library(rflann)
library(e1071)
library(svd)
source('../../Main/utils.R')
sourceCpp('/home/sam/Documents/FBT/Single/package/Rare/src/utils.cpp')
auc.mat <- matrix(NA, 100, 150)
for(i in 1:100){
load(paste("CD14_20_cells_", i, "_ExprM.RData",sep=""))
data <- CD14.20.cells[rowMeans(CD14.20.cells) > 0,]
norm.data <- .normalize_by_umi(t(data), gene_symbols = dimnames(data)[[1]], minLibSize=0, verbose = F)
data3 <- t(norm.data$m)
group <- ifelse(grepl('CD14', dimnames(data3)[[2]]), 'Group1', 'Group2')
DE <- WilcoxDETest((data3 + 1), cells.1 = dimnames(data3)[[2]][group=='Group1'],
cells.2 = dimnames(data3)[[2]][group=='Group2'], verbose = F)
logFC <- apply(data3, 1, function(x){log(mean(x[group=='Group1'])/mean(x[group=='Group2']))})
mic <- c()
for(i in 1:dim(data3)[1]){
mic <- c(mic, minerva::mine_stat(data3[i,], as.integer(factor(group))))
}
DE.ind <- which(abs(logFC) > log2(5) & p.adjust(DE$p_val, 'fdr') < 0.05)
DE.top <- DE.ind[order(mic[DE.ind], decreasing = T)[1:150]]
NDE.ind <- which(DE$p_val >= 0.05)
set.seed(2019)
DE.range <- 1:150
auc.vec <- c()
for(num in DE.range){
auc <- c()
DE.top.num <- DE.top[(length(DE.top) - num + 1):length(DE.top)]
data <- rbind(data3[NDE.ind,], data3[DE.top.num,])
disp <- FastLogVMR(as(data, 'dgCMatrix'), F)
pca <- calcul.pca(t(data[order(disp, decreasing = T)[1:2000],]), 50)
knn.res <- Neighbour(pca$pca, pca$pca, k=200)
skew <- c()
for(j in 3:200){
pp <- apply(knn.res$distances, 1, function(x){sum(1/x[2:j])})
ww <- apply(knn.res$distances, 1, function(x){sum(1/(x[2:j])^2)})
a <- (ww)^(1/2)/pp
a1 <- c()
for(k in 1:dim(pca$pca)[1]){a1 <- c(a1, (a[k] + a[knn.res$indices[k,2]])/2)}
skew <- c(skew, skewness(a1))
}
max.ids <- (3:200)[which.peaks(skew)]
if(length(max.ids) > 1){
delta.r <- c()
for(max.id in max.ids){
pp <- apply(knn.res$distances, 1, function(x){sum(1/x[2:max.id])})
ww <- apply(knn.res$distances, 1, function(x){sum(1/(x[2:max.id])^2)})
a <- (ww)^(1/2)/pp
a1 <- c()
for(k in 1:dim(pca$pca)[1]){a1 <- c(a1, (a[k] + a[knn.res$indices[k,2]])/2)}
ave <- apply(knn.res$distances[,2:max.id], 1, mean)
fit <- lm(log(ave/a1)~log(ave))
r1 <- (summary(fit)$adj.r.squared)
big.id <- which(ave > quantile(ave, 0.25))
fit1 <- lm(log(ave[big.id]/a1[big.id])~log(ave[big.id]))
r2 <- (summary(fit1)$adj.r.squared)
delta.r <- c(delta.r, r1 - r2)
}
best.k <- max.ids[which.max(delta.r)]
}else{
best.k <- max.ids[1]
}
pp <- apply(knn.res$distances, 1, function(x){sum(1/x[2:best.k])})
ww <- apply(knn.res$distances, 1, function(x){sum(1/(x[2:best.k])^2)})
a <- (ww)^(1/2)/pp
a1 <- c()
for(k in 1:dim(pca$pca)[1]){a1 <- c(a1, (a[k] + a[knn.res$indices[k,2]])/2)}
ave <- apply(knn.res$distances[,2:best.k], 1, mean)
remain = which(ave > quantile(ave, 0.25))
den <- density(a1[remain])
mid.val <- (min(den$x) + max(den$x))/2
mid <- min(which(den$x > mid.val))
elbow <- find_elbow(den$x[which.max(den$y):mid], den$y[which.max(den$y):mid])
filtered <- remain[a1[remain] > elbow]
res <- dbscan::hdbscan(pca$pca[filtered,], minPts = 2)
cluster.ave <- tapply(a1[filtered], res$cluster, mean)
best.cluster <- names(cluster.ave)[which.max(cluster.ave)]
predictions <- ifelse(1:dim(pca$pca)[1] %in% filtered[res$cluster == best.cluster], 1, 2)
pred <- prediction(predictions, group)
perf <- performance(pred, "auc")
auc <- c(auc, perf@y.values[[1]])
print(num)
print(perf@y.values[[1]])
auc.vec <- c(auc.vec, auc)
}
auc.mat[i,] <- auc.vec
}
#auc.res <- list(auc.ave, auc.std)
#save(auc.res, file='./results/AUC_res.RData')
str(auc.ave)
str(auc.vec)
plot(1:150, auc.ave)
plot(1:150, auc.vec)
plot(1:150, auc.vec, cex=0.1)
str(auc.mat)
i
workdir              = "/home/sam/Documents/RareCellDetection/Proj/10X_DE_sensitivity/"
# where you put the data and results
setwd(workdir)
library(pbapply)
library(future.apply)
library(ROCR)
library(Rcpp)
library(splatter)
library(rflann)
library(e1071)
library(svd)
source('../../Main/utils.R')
sourceCpp('/home/sam/Documents/FBT/Single/package/Rare/src/utils.cpp')
auc.mat <- matrix(NA, 100, 200)
for(m in 1:100){
load(paste("CD14_20_cells_", m, "_ExprM.RData",sep=""))
data <- CD14.20.cells[rowMeans(CD14.20.cells) > 0,]
norm.data <- .normalize_by_umi(t(data), gene_symbols = dimnames(data)[[1]], minLibSize=0, verbose = F)
data3 <- t(norm.data$m)
group <- ifelse(grepl('CD14', dimnames(data3)[[2]]), 'Group1', 'Group2')
DE <- WilcoxDETest((data3 + 1), cells.1 = dimnames(data3)[[2]][group=='Group1'],
cells.2 = dimnames(data3)[[2]][group=='Group2'], verbose = F)
logFC <- apply(data3, 1, function(x){log(mean(x[group=='Group1'])/mean(x[group=='Group2']))})
mic <- c()
for(i in 1:dim(data3)[1]){
mic <- c(mic, minerva::mine_stat(data3[i,], as.integer(factor(group))))
}
DE.ind <- which(abs(logFC) > log2(5) & p.adjust(DE$p_val, 'fdr') < 0.05)
DE.top <- DE.ind[order(mic[DE.ind], decreasing = T)[1:200]]
NDE.ind <- which(DE$p_val >= 0.05)
set.seed(2019)
DE.range <- 1:200
auc.vec <- c()
for(num in DE.range){
auc <- c()
DE.top.num <- DE.top[(length(DE.top) - num + 1):length(DE.top)]
data <- rbind(data3[NDE.ind,], data3[DE.top.num,])
disp <- FastLogVMR(as(data, 'dgCMatrix'), F)
pca <- calcul.pca(t(data[order(disp, decreasing = T)[1:2000],]), 50)
knn.res <- Neighbour(pca$pca, pca$pca, k=200)
skew <- c()
for(j in 3:200){
pp <- apply(knn.res$distances, 1, function(x){sum(1/x[2:j])})
ww <- apply(knn.res$distances, 1, function(x){sum(1/(x[2:j])^2)})
a <- (ww)^(1/2)/pp
a1 <- c()
for(k in 1:dim(pca$pca)[1]){a1 <- c(a1, (a[k] + a[knn.res$indices[k,2]])/2)}
skew <- c(skew, skewness(a1))
}
max.ids <- (3:200)[which.peaks(skew)]
if(length(max.ids) > 1){
delta.r <- c()
for(max.id in max.ids){
pp <- apply(knn.res$distances, 1, function(x){sum(1/x[2:max.id])})
ww <- apply(knn.res$distances, 1, function(x){sum(1/(x[2:max.id])^2)})
a <- (ww)^(1/2)/pp
a1 <- c()
for(k in 1:dim(pca$pca)[1]){a1 <- c(a1, (a[k] + a[knn.res$indices[k,2]])/2)}
ave <- apply(knn.res$distances[,2:max.id], 1, mean)
fit <- lm(log(ave/a1)~log(ave))
r1 <- (summary(fit)$adj.r.squared)
big.id <- which(ave > quantile(ave, 0.25))
fit1 <- lm(log(ave[big.id]/a1[big.id])~log(ave[big.id]))
r2 <- (summary(fit1)$adj.r.squared)
delta.r <- c(delta.r, r1 - r2)
}
best.k <- max.ids[which.max(delta.r)]
}else{
best.k <- max.ids[1]
}
pp <- apply(knn.res$distances, 1, function(x){sum(1/x[2:best.k])})
ww <- apply(knn.res$distances, 1, function(x){sum(1/(x[2:best.k])^2)})
a <- (ww)^(1/2)/pp
a1 <- c()
for(k in 1:dim(pca$pca)[1]){a1 <- c(a1, (a[k] + a[knn.res$indices[k,2]])/2)}
ave <- apply(knn.res$distances[,2:best.k], 1, mean)
remain = which(ave > quantile(ave, 0.25))
den <- density(a1[remain])
mid.val <- (min(den$x) + max(den$x))/2
mid <- min(which(den$x > mid.val))
elbow <- find_elbow(den$x[which.max(den$y):mid], den$y[which.max(den$y):mid])
filtered <- remain[a1[remain] > elbow]
res <- dbscan::hdbscan(pca$pca[filtered,], minPts = 2)
cluster.ave <- tapply(a1[filtered], res$cluster, mean)
best.cluster <- names(cluster.ave)[which.max(cluster.ave)]
predictions <- ifelse(1:dim(pca$pca)[1] %in% filtered[res$cluster == best.cluster], 1, 2)
pred <- prediction(predictions, group)
perf <- performance(pred, "auc")
auc <- c(auc, perf@y.values[[1]])
print(num)
print(perf@y.values[[1]])
auc.vec <- c(auc.vec, auc)
}
auc.mat[i,] <- auc.vec
}
